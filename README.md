# CWP/TASK/21 - N-layer архитектура

function task00() {

Создаем на Github репозиторий cwp-21, клонируем его, открываем в IDE

Установим библиотеки express, sequelize, joi, winston и lru-cache

Изучим ещё раз слои N-layer модели и пример её реализации из 10-ой лекции

}

function task01() {

Создадим слой моделей. Таблицы базы данных будем создавать с помощью подхода code first

1. Таблица Properties / Недвижимость

"id": int / autoincrement

"heading": string

"price": int

"currency": string

"location": string

"agentId": int / reference to "agents"

2. Таблица Agents / Агенты

"id": int / autoincrement

"name": string

"email": string

"tel": string

"officeId": int / reference to "offices"

3. Таблица Offices / Офисы

"id": int / autoincrement

"title": string

"website": string

"address": string

}

function task02() {

Создадим слой контекста задав связи указанные в описании моделей

Выполним создание таблиц в базе данных через синхронизацию

}

function task03() {

Создадим слой сервисов. Все методы сервисов должны быть помечены ключевым словом async и использовать await для ожидания промисов

1. Сервис для недвижимости должен предоставлять операциии:

a) чтения порции данных с возможностью задания limit (от 5 до 25 с шагом 5), offset, sortOrder, sortField

b) чтение по id, проверка является ли id числом

c) создание записи, с валидацией через joi - price больше 0, currency - BYN, USD или EUR, оставшиеся поля не пустые

d) обновление записи по id с валидацией через joi

e) удаление записи по id

f) привязка агента

g) отвязка агента

2. Сервис для агентов должен предоставлять операциии:

a) чтения порции данных с возможностью задания limit, offset, sortOrder, sortField

b) чтение по id, проверка является ли id числом

c) создание записи, с валидацией через joi - email - адрес почты, оставшиеся поля не пустые

d) обновление записи по id с валидацией через joi

e) удаление записи по id, с отвязкой недвижимости

f) привязка к офису

g) отвязка от офиса

h) чтение привязанной недвижемости по id агента с возможностью задания limit, offset

3. Сервис для офисов должен предоставлять операциии:

a) чтения порции данных с возможностью задания limit, offset, sortOrder, sortField

b) чтение по id, проверка является ли id числом

c) создание записи, с валидацией через joi - поля не пустые

d) обновление записи по id с валидацией через joi

e) удаление записи по id, с отвязкой агентов

f) чтение привязанных агентов по id офиса с возможностью задания limit, offset

}

function task04() {

Создадим слой контроллеров - по одному контроллеру на каждый сервис. Контроллеры оформлять в виде отдельных express-роутеров. Контролеры должны предоставлять доступ ко всем методам сервисов через HTTP.

Все методы контроллеров должны быть помечены ключевым словом async и использовать await для ожидания промисов

}

function task05() {

Создадим глобальный контроллер по отлову ошибок как в примере 10-ой лекции

}

function task06() {

Создадим глобальный контроллер логгирования используя winston. Запись логов в файл, максимальный размер файла 0.5 Кб. Записываем дату и время запроса (можем использовать moment для форматирования), URL, метод запроса, полезную нагрузку (body и query)

Для корретной реализации этого контроллера вам понадобиться вернуться на слой сервисов и реализовать сервис логирования

}

function task07() {

Создадим глобальный контроллер кэширования используя lru-cache. Максимальный размер кэша - 5, максимальное время хранения в кэше - 30 секунд. При успешной отдаче из кэша записывать в лог URL, метод и строку "FROM CACHE". Ключом для кэширования может быть комбинация из URL(включая query параметры)+метод. Кэшироваться должны только GET запросы.

Для корретной реализации этого контроллера вам понадобиться вернуться на слой сервисов и реализовать сервис кэширования

}

function task08() {

Запустим сервер и проверим его работу

}

function task09() {

Синхронизируем локальный репозиторий с удаленным (сделаем push на Github)

}